# -*- coding: utf-8 -*-
"""RMPData (1).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1AP02Gpu6gN2WJ5pYuGenW9gOKgk_H4CB
"""

# ## ignore this, it has to do with a visual check I did
# RMPnames = reviews['prof_name'].value_counts().index
# matches = []
# for name in RMPnames:
#     match = fw.process.extract(name, names, limit=2)
#     if match[1][1] > 87:
#         print(name, match[1])
#     matches.append(match)

# ### ignore this, it had to do with seeing how many exact matches existed
# count = 0
# bleh = 0
# for name in realnames:
#     try:
#         match = fw.process.extract(name, rmpnames, limit=1)
#         if (match[0][1] == 100):
#             count += 1
#     except:
#         bleh += 1

# print(count, bleh)
# print(count / len(realnames))



# !pip install fuzzywuzzy
# !pip install boto3

import numpy as np
import pandas as pd
import fuzzywuzzy as fw
from fuzzywuzzy import process
import boto3
import botocore
from botocore import UNSIGNED
from botocore.config import Config
import json

# reading in course data from bucket
d=None
BUCKET_NAME = 'cornell-course-data-bucket'
PATH = 'course_data_2.json'
s3 = boto3.resource('s3', config=Config(signature_version=UNSIGNED))

content_object = s3.Object(BUCKET_NAME, PATH)
file_content = content_object.get()['Body'].read().decode('utf-8-sig')
d = json.loads(file_content)

x = pd.DataFrame(d)

## making new column with full name
x['firstNLastN'] = x['firstName'] + ' ' + x['lastName']

#reading in rmp reviews
reviews = pd.read_json(path_or_buf = 'rate_my_professor.json')

### dict which maps teachers with multiple names on RMP to a single name. This does not solve all the multiple
### issues, just the most readily visible ones. I made it from an earlier exploration of the dataset, dw abt it
namefixdict = {
    'Thomas Gilovich'         :  'Tom Gilovich',
    'Nick Salvato'         :  'Nick Salvatore',
    'Dr. Aparna Thomas'    :      'Aparna Thomas',
    'Mike Amburgh'         :     'Mike Van Amburgh',
    'Christian Danescu': 'Cristian Danescu-Niculescu-Mizil'
}

## applying the dict above to reduce names in rmp dataset
newrows = []
for index, row in reviews.iterrows():
    
    if row['prof_name'] in namefixdict.keys():
            row['prof_name'] = namefixdict[row['prof_name']]
            
    newrows.append(row)

newreviews = pd.DataFrame(newrows)



review_link = 'https://www.ratemyprofessors.com/ShowRatings.jsp?tid='
ids = np.array(pd.DataFrame(newreviews.groupby(['prof_name']).first()['prof_id'])['prof_id'])

##making df with average values grouped by professor name
reviews_by_name = pd.DataFrame(newreviews.groupby(['prof_name']).mean()['difficulty']).reset_index()

ratings = np.array(pd.DataFrame(newreviews.groupby(['prof_name']).mean()['rating'])['rating'])
take_again = np.array(pd.DataFrame(newreviews.groupby(['prof_name']).mean()['take_again'])['take_again'])
counts = np.array(pd.DataFrame(newreviews.rename(columns={"comment":'RMPCount'}).groupby(['prof_name']).count()['RMPCount'])['RMPCount'])

reviews_by_name['rating'] = ratings
reviews_by_name['take_again'] = take_again
reviews_by_name['link'] = ids 
reviews_by_name['RMPLink'] = reviews_by_name['link'].apply(lambda x: review_link+str(x))
reviews_by_name['RMPCount']=counts

rmpnames = reviews_by_name['prof_name'].value_counts().index



# ##testarea, ignore this

# rating_map = {}
# difficulty_map = {}
# takeagain_map = {}
# rmpname_map = {}
# problem = 0
# problemnames = set()

# for name in x['firstNLastN']:
#     match = fw.process.extract(name, rmpnames, limit=1)
#     score = match[0][1]
#     matchname = match[0][0]
#     if (score >= 89):
#         rating_map[name] = reviews_by_name['rating'][reviews_by_name['prof_name'] == name].iloc[0]
#         difficulty_map[name] = reviews_by_name['difficulty'][reviews_by_name['prof_name'] == name].iloc[0]
#         takeagain_map[name] = reviews_by_name['take_again'][reviews_by_name['prof_name'] == name].iloc[0]
#         rmpname_map[name] = matchname
#         print(name, matchname, rating_map[name], difficulty_map[name], takeagain_map[name])
#     else:
#         rating_map[name] = None
#         difficulty_map[name] = None
#         takeagain_map[name] = None
#         rmpname_map[name] = None
#         problem += 1
#         problemnames.add(name)
#         print(name, matchname, 'lowscore')

## creating map from professor name to their average rating, difficulty, and takeagain. Also storing the RMP name
## for the 'report' button. This takes forever to run on my computer (~20 mins, the fuzzywuzzy edit distance thing
## takes forever)
rating_map = {}
difficulty_map = {}
takeagain_map = {}
rmpname_map = {}
problem = 0
problemnames = set()

for name in x['firstNLastN']:
    try:
        match = fw.process.extract(name, rmpnames, limit=1)
        score = match[0][1]
        matchname = match[0][0]
        if (score >= 89):
            rating_map[name] = reviews_by_name['rating'][reviews_by_name['prof_name'] == name].iloc[0]
            difficulty_map[name] = reviews_by_name['difficulty'][reviews_by_name['prof_name'] == name].iloc[0]
            takeagain_map[name] = reviews_by_name['take_again'][reviews_by_name['prof_name'] == name].iloc[0]
            rmpname_map[name] = matchname
        else:
            rating_map[name] = None
            difficulty_map[name] = None
            takeagain_map[name] = None
            rmpname_map[name] = None
            problem += 1
            problemnames.add(name)
            
    except:
        rating_map[name] = None
        difficulty_map[name] = None
        takeagain_map[name] = None
        problem += 1
        problemnames.add(name)

## creating new colmns with the maps I just made

x['RMPrating'] = x['firstNLastN'].map(rating_map)
x['RMPprofname'] = x['firstNLastN'].map(rmpname_map)
x['RMPdifficulty'] = x['firstNLastN'].map(difficulty_map)
x['RMPtakeagain'] = x['firstNLastN'].map(takeagain_map)

reviews_by_name_links = reviews_by_name[['prof_name','RMPLink', 'RMPCount']]
x = x.merge(reviews_by_name_links,left_on='RMPprofname', right_on='prof_name',how='left').drop('prof_name',axis=1)

import math
x['RMPCount']=x.RMPCount.astype('Int64')
x['RMPtakeagain'] = x.RMPtakeagain.apply(lambda a: a if math.isnan(a) else np.round(a*100,2))

# exporting to new json
x.to_json("course_data_3.json",orient="records")